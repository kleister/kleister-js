/* tslint:disable */
/* eslint-disable */
/**
 * Kleister OpenAPI
 * API definition for Kleister, manage mod packs for Minecraft
 *
 * The version of the OpenAPI document: 1.0.0-alpha1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { BuildVersion } from '../model';
// @ts-ignore
import { GeneralError } from '../model';
// @ts-ignore
import { Mod } from '../model';
// @ts-ignore
import { ModTeamParams } from '../model';
// @ts-ignore
import { ModUserParams } from '../model';
// @ts-ignore
import { TeamMod } from '../model';
// @ts-ignore
import { UserMod } from '../model';
// @ts-ignore
import { ValidationError } from '../model';
// @ts-ignore
import { Version } from '../model';
// @ts-ignore
import { VersionBuildParams } from '../model';
/**
 * ModApi - axios parameter creator
 * @export
 */
export const ModApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Assign a team to mod
         * @param {string} modId A mod UUID or slug
         * @param {ModTeamParams} modTeam The mod team data to assign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appendModToTeam: async (modId: string, modTeam: ModTeamParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modId' is not null or undefined
            assertParamExists('appendModToTeam', 'modId', modId)
            // verify required parameter 'modTeam' is not null or undefined
            assertParamExists('appendModToTeam', 'modTeam', modTeam)
            const localVarPath = `/mods/{mod_id}/teams`
                .replace(`{${"mod_id"}}`, encodeURIComponent(String(modId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modTeam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Assign a user to mod
         * @param {string} modId A mod UUID or slug
         * @param {ModUserParams} modUser The mod user data to assign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appendModToUser: async (modId: string, modUser: ModUserParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modId' is not null or undefined
            assertParamExists('appendModToUser', 'modId', modId)
            // verify required parameter 'modUser' is not null or undefined
            assertParamExists('appendModToUser', 'modUser', modUser)
            const localVarPath = `/mods/{mod_id}/users`
                .replace(`{${"mod_id"}}`, encodeURIComponent(String(modId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Assign a build to a version
         * @param {string} modId A mod UUID or slug
         * @param {string} versionId A version UUID or slug
         * @param {VersionBuildParams} versionBuild The build data to append to version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appendVersionToBuild: async (modId: string, versionId: string, versionBuild: VersionBuildParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modId' is not null or undefined
            assertParamExists('appendVersionToBuild', 'modId', modId)
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('appendVersionToBuild', 'versionId', versionId)
            // verify required parameter 'versionBuild' is not null or undefined
            assertParamExists('appendVersionToBuild', 'versionBuild', versionBuild)
            const localVarPath = `/mods/{mod_id}/versions/{version_id}/builds`
                .replace(`{${"mod_id"}}`, encodeURIComponent(String(modId)))
                .replace(`{${"version_id"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(versionBuild, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new mod
         * @param {Mod} mod The mod data to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMod: async (mod: Mod, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mod' is not null or undefined
            assertParamExists('createMod', 'mod', mod)
            const localVarPath = `/mods`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mod, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new version for a mod
         * @param {string} modId A mod UUID or slug
         * @param {Version} version The version data to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVersion: async (modId: string, version: Version, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modId' is not null or undefined
            assertParamExists('createVersion', 'modId', modId)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('createVersion', 'version', version)
            const localVarPath = `/mods/{mod_id}/versions`
                .replace(`{${"mod_id"}}`, encodeURIComponent(String(modId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(version, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a specific mod
         * @param {string} modId A mod UUID or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMod: async (modId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modId' is not null or undefined
            assertParamExists('deleteMod', 'modId', modId)
            const localVarPath = `/mods/{mod_id}`
                .replace(`{${"mod_id"}}`, encodeURIComponent(String(modId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a team from mod
         * @param {string} modId A mod UUID or slug
         * @param {ModTeamParams} modTeam The mod team data to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteModFromTeam: async (modId: string, modTeam: ModTeamParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modId' is not null or undefined
            assertParamExists('deleteModFromTeam', 'modId', modId)
            // verify required parameter 'modTeam' is not null or undefined
            assertParamExists('deleteModFromTeam', 'modTeam', modTeam)
            const localVarPath = `/mods/{mod_id}/teams`
                .replace(`{${"mod_id"}}`, encodeURIComponent(String(modId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modTeam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a user from mod
         * @param {string} modId A mod UUID or slug
         * @param {ModUserParams} modUser The mod user data to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteModFromUser: async (modId: string, modUser: ModUserParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modId' is not null or undefined
            assertParamExists('deleteModFromUser', 'modId', modId)
            // verify required parameter 'modUser' is not null or undefined
            assertParamExists('deleteModFromUser', 'modUser', modUser)
            const localVarPath = `/mods/{mod_id}/users`
                .replace(`{${"mod_id"}}`, encodeURIComponent(String(modId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a specific version for a mod
         * @param {string} modId A mod UUID or slug
         * @param {string} versionId A version UUID or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVersion: async (modId: string, versionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modId' is not null or undefined
            assertParamExists('deleteVersion', 'modId', modId)
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('deleteVersion', 'versionId', versionId)
            const localVarPath = `/mods/{mod_id}/versions/{version_id}`
                .replace(`{${"mod_id"}}`, encodeURIComponent(String(modId)))
                .replace(`{${"version_id"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unlink a build from a version
         * @param {string} modId A mod UUID or slug
         * @param {string} versionId A version UUID or slug
         * @param {VersionBuildParams} versionBuild The build data to unlink from version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVersionFromBuild: async (modId: string, versionId: string, versionBuild: VersionBuildParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modId' is not null or undefined
            assertParamExists('deleteVersionFromBuild', 'modId', modId)
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('deleteVersionFromBuild', 'versionId', versionId)
            // verify required parameter 'versionBuild' is not null or undefined
            assertParamExists('deleteVersionFromBuild', 'versionBuild', versionBuild)
            const localVarPath = `/mods/{mod_id}/versions/{version_id}/builds`
                .replace(`{${"mod_id"}}`, encodeURIComponent(String(modId)))
                .replace(`{${"version_id"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(versionBuild, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch all teams assigned to mod
         * @param {string} modId A mod UUID or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listModTeams: async (modId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modId' is not null or undefined
            assertParamExists('listModTeams', 'modId', modId)
            const localVarPath = `/mods/{mod_id}/teams`
                .replace(`{${"mod_id"}}`, encodeURIComponent(String(modId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch all users assigned to mod
         * @param {string} modId A mod UUID or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listModUsers: async (modId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modId' is not null or undefined
            assertParamExists('listModUsers', 'modId', modId)
            const localVarPath = `/mods/{mod_id}/users`
                .replace(`{${"mod_id"}}`, encodeURIComponent(String(modId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch all available mods
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMods: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mods`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch all builds assigned to version
         * @param {string} modId A mod UUID or slug
         * @param {string} versionId A version UUID or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVersionBuilds: async (modId: string, versionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modId' is not null or undefined
            assertParamExists('listVersionBuilds', 'modId', modId)
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('listVersionBuilds', 'versionId', versionId)
            const localVarPath = `/mods/{mod_id}/versions/{version_id}/builds`
                .replace(`{${"mod_id"}}`, encodeURIComponent(String(modId)))
                .replace(`{${"version_id"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch all available versions for a mod
         * @param {string} modId A mod UUID or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVersions: async (modId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modId' is not null or undefined
            assertParamExists('listVersions', 'modId', modId)
            const localVarPath = `/mods/{mod_id}/versions`
                .replace(`{${"mod_id"}}`, encodeURIComponent(String(modId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update team perms for mod
         * @param {string} modId A mod UUID or slug
         * @param {ModTeamParams} modTeam The mod team data to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permitModTeam: async (modId: string, modTeam: ModTeamParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modId' is not null or undefined
            assertParamExists('permitModTeam', 'modId', modId)
            // verify required parameter 'modTeam' is not null or undefined
            assertParamExists('permitModTeam', 'modTeam', modTeam)
            const localVarPath = `/mods/{mod_id}/teams`
                .replace(`{${"mod_id"}}`, encodeURIComponent(String(modId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modTeam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user perms for mod
         * @param {string} modId A mod UUID or slug
         * @param {ModUserParams} modUser The mod user data to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permitModUser: async (modId: string, modUser: ModUserParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modId' is not null or undefined
            assertParamExists('permitModUser', 'modId', modId)
            // verify required parameter 'modUser' is not null or undefined
            assertParamExists('permitModUser', 'modUser', modUser)
            const localVarPath = `/mods/{mod_id}/users`
                .replace(`{${"mod_id"}}`, encodeURIComponent(String(modId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch a specific mod
         * @param {string} modId A mod UUID or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showMod: async (modId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modId' is not null or undefined
            assertParamExists('showMod', 'modId', modId)
            const localVarPath = `/mods/{mod_id}`
                .replace(`{${"mod_id"}}`, encodeURIComponent(String(modId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch a specific version for a mod
         * @param {string} modId A mod UUID or slug
         * @param {string} versionId A version UUID or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showVersion: async (modId: string, versionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modId' is not null or undefined
            assertParamExists('showVersion', 'modId', modId)
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('showVersion', 'versionId', versionId)
            const localVarPath = `/mods/{mod_id}/versions/{version_id}`
                .replace(`{${"mod_id"}}`, encodeURIComponent(String(modId)))
                .replace(`{${"version_id"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a specific mod
         * @param {string} modId A mod UUID or slug
         * @param {Mod} mod The mod data to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMod: async (modId: string, mod: Mod, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modId' is not null or undefined
            assertParamExists('updateMod', 'modId', modId)
            // verify required parameter 'mod' is not null or undefined
            assertParamExists('updateMod', 'mod', mod)
            const localVarPath = `/mods/{mod_id}`
                .replace(`{${"mod_id"}}`, encodeURIComponent(String(modId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mod, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a specific version for a mod
         * @param {string} modId A mod UUID or slug
         * @param {string} versionId A version UUID or slug
         * @param {Version} version The version data to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVersion: async (modId: string, versionId: string, version: Version, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modId' is not null or undefined
            assertParamExists('updateVersion', 'modId', modId)
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('updateVersion', 'versionId', versionId)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('updateVersion', 'version', version)
            const localVarPath = `/mods/{mod_id}/versions/{version_id}`
                .replace(`{${"mod_id"}}`, encodeURIComponent(String(modId)))
                .replace(`{${"version_id"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(version, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ModApi - functional programming interface
 * @export
 */
export const ModApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ModApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Assign a team to mod
         * @param {string} modId A mod UUID or slug
         * @param {ModTeamParams} modTeam The mod team data to assign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appendModToTeam(modId: string, modTeam: ModTeamParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeneralError>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appendModToTeam(modId, modTeam, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Assign a user to mod
         * @param {string} modId A mod UUID or slug
         * @param {ModUserParams} modUser The mod user data to assign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appendModToUser(modId: string, modUser: ModUserParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeneralError>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appendModToUser(modId, modUser, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Assign a build to a version
         * @param {string} modId A mod UUID or slug
         * @param {string} versionId A version UUID or slug
         * @param {VersionBuildParams} versionBuild The build data to append to version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appendVersionToBuild(modId: string, versionId: string, versionBuild: VersionBuildParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeneralError>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appendVersionToBuild(modId, versionId, versionBuild, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new mod
         * @param {Mod} mod The mod data to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMod(mod: Mod, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Mod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMod(mod, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new version for a mod
         * @param {string} modId A mod UUID or slug
         * @param {Version} version The version data to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVersion(modId: string, version: Version, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Version>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVersion(modId, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a specific mod
         * @param {string} modId A mod UUID or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMod(modId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeneralError>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMod(modId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove a team from mod
         * @param {string} modId A mod UUID or slug
         * @param {ModTeamParams} modTeam The mod team data to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteModFromTeam(modId: string, modTeam: ModTeamParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeneralError>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteModFromTeam(modId, modTeam, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove a user from mod
         * @param {string} modId A mod UUID or slug
         * @param {ModUserParams} modUser The mod user data to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteModFromUser(modId: string, modUser: ModUserParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeneralError>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteModFromUser(modId, modUser, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a specific version for a mod
         * @param {string} modId A mod UUID or slug
         * @param {string} versionId A version UUID or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVersion(modId: string, versionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeneralError>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVersion(modId, versionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unlink a build from a version
         * @param {string} modId A mod UUID or slug
         * @param {string} versionId A version UUID or slug
         * @param {VersionBuildParams} versionBuild The build data to unlink from version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVersionFromBuild(modId: string, versionId: string, versionBuild: VersionBuildParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeneralError>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVersionFromBuild(modId, versionId, versionBuild, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetch all teams assigned to mod
         * @param {string} modId A mod UUID or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listModTeams(modId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TeamMod>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listModTeams(modId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetch all users assigned to mod
         * @param {string} modId A mod UUID or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listModUsers(modId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserMod>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listModUsers(modId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetch all available mods
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMods(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Mod>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMods(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetch all builds assigned to version
         * @param {string} modId A mod UUID or slug
         * @param {string} versionId A version UUID or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVersionBuilds(modId: string, versionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BuildVersion>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listVersionBuilds(modId, versionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetch all available versions for a mod
         * @param {string} modId A mod UUID or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVersions(modId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Version>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listVersions(modId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update team perms for mod
         * @param {string} modId A mod UUID or slug
         * @param {ModTeamParams} modTeam The mod team data to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async permitModTeam(modId: string, modTeam: ModTeamParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeneralError>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.permitModTeam(modId, modTeam, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update user perms for mod
         * @param {string} modId A mod UUID or slug
         * @param {ModUserParams} modUser The mod user data to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async permitModUser(modId: string, modUser: ModUserParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeneralError>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.permitModUser(modId, modUser, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetch a specific mod
         * @param {string} modId A mod UUID or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showMod(modId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Mod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showMod(modId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetch a specific version for a mod
         * @param {string} modId A mod UUID or slug
         * @param {string} versionId A version UUID or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showVersion(modId: string, versionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Version>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showVersion(modId, versionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a specific mod
         * @param {string} modId A mod UUID or slug
         * @param {Mod} mod The mod data to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMod(modId: string, mod: Mod, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Mod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMod(modId, mod, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a specific version for a mod
         * @param {string} modId A mod UUID or slug
         * @param {string} versionId A version UUID or slug
         * @param {Version} version The version data to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVersion(modId: string, versionId: string, version: Version, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Version>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateVersion(modId, versionId, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ModApi - factory interface
 * @export
 */
export const ModApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ModApiFp(configuration)
    return {
        /**
         * 
         * @summary Assign a team to mod
         * @param {string} modId A mod UUID or slug
         * @param {ModTeamParams} modTeam The mod team data to assign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appendModToTeam(modId: string, modTeam: ModTeamParams, options?: any): AxiosPromise<GeneralError> {
            return localVarFp.appendModToTeam(modId, modTeam, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Assign a user to mod
         * @param {string} modId A mod UUID or slug
         * @param {ModUserParams} modUser The mod user data to assign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appendModToUser(modId: string, modUser: ModUserParams, options?: any): AxiosPromise<GeneralError> {
            return localVarFp.appendModToUser(modId, modUser, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Assign a build to a version
         * @param {string} modId A mod UUID or slug
         * @param {string} versionId A version UUID or slug
         * @param {VersionBuildParams} versionBuild The build data to append to version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appendVersionToBuild(modId: string, versionId: string, versionBuild: VersionBuildParams, options?: any): AxiosPromise<GeneralError> {
            return localVarFp.appendVersionToBuild(modId, versionId, versionBuild, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new mod
         * @param {Mod} mod The mod data to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMod(mod: Mod, options?: any): AxiosPromise<Mod> {
            return localVarFp.createMod(mod, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new version for a mod
         * @param {string} modId A mod UUID or slug
         * @param {Version} version The version data to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVersion(modId: string, version: Version, options?: any): AxiosPromise<Version> {
            return localVarFp.createVersion(modId, version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a specific mod
         * @param {string} modId A mod UUID or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMod(modId: string, options?: any): AxiosPromise<GeneralError> {
            return localVarFp.deleteMod(modId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a team from mod
         * @param {string} modId A mod UUID or slug
         * @param {ModTeamParams} modTeam The mod team data to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteModFromTeam(modId: string, modTeam: ModTeamParams, options?: any): AxiosPromise<GeneralError> {
            return localVarFp.deleteModFromTeam(modId, modTeam, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a user from mod
         * @param {string} modId A mod UUID or slug
         * @param {ModUserParams} modUser The mod user data to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteModFromUser(modId: string, modUser: ModUserParams, options?: any): AxiosPromise<GeneralError> {
            return localVarFp.deleteModFromUser(modId, modUser, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a specific version for a mod
         * @param {string} modId A mod UUID or slug
         * @param {string} versionId A version UUID or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVersion(modId: string, versionId: string, options?: any): AxiosPromise<GeneralError> {
            return localVarFp.deleteVersion(modId, versionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unlink a build from a version
         * @param {string} modId A mod UUID or slug
         * @param {string} versionId A version UUID or slug
         * @param {VersionBuildParams} versionBuild The build data to unlink from version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVersionFromBuild(modId: string, versionId: string, versionBuild: VersionBuildParams, options?: any): AxiosPromise<GeneralError> {
            return localVarFp.deleteVersionFromBuild(modId, versionId, versionBuild, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch all teams assigned to mod
         * @param {string} modId A mod UUID or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listModTeams(modId: string, options?: any): AxiosPromise<Array<TeamMod>> {
            return localVarFp.listModTeams(modId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch all users assigned to mod
         * @param {string} modId A mod UUID or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listModUsers(modId: string, options?: any): AxiosPromise<Array<UserMod>> {
            return localVarFp.listModUsers(modId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch all available mods
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMods(options?: any): AxiosPromise<Array<Mod>> {
            return localVarFp.listMods(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch all builds assigned to version
         * @param {string} modId A mod UUID or slug
         * @param {string} versionId A version UUID or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVersionBuilds(modId: string, versionId: string, options?: any): AxiosPromise<Array<BuildVersion>> {
            return localVarFp.listVersionBuilds(modId, versionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch all available versions for a mod
         * @param {string} modId A mod UUID or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVersions(modId: string, options?: any): AxiosPromise<Array<Version>> {
            return localVarFp.listVersions(modId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update team perms for mod
         * @param {string} modId A mod UUID or slug
         * @param {ModTeamParams} modTeam The mod team data to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permitModTeam(modId: string, modTeam: ModTeamParams, options?: any): AxiosPromise<GeneralError> {
            return localVarFp.permitModTeam(modId, modTeam, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user perms for mod
         * @param {string} modId A mod UUID or slug
         * @param {ModUserParams} modUser The mod user data to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permitModUser(modId: string, modUser: ModUserParams, options?: any): AxiosPromise<GeneralError> {
            return localVarFp.permitModUser(modId, modUser, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch a specific mod
         * @param {string} modId A mod UUID or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showMod(modId: string, options?: any): AxiosPromise<Mod> {
            return localVarFp.showMod(modId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch a specific version for a mod
         * @param {string} modId A mod UUID or slug
         * @param {string} versionId A version UUID or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showVersion(modId: string, versionId: string, options?: any): AxiosPromise<Version> {
            return localVarFp.showVersion(modId, versionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a specific mod
         * @param {string} modId A mod UUID or slug
         * @param {Mod} mod The mod data to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMod(modId: string, mod: Mod, options?: any): AxiosPromise<Mod> {
            return localVarFp.updateMod(modId, mod, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a specific version for a mod
         * @param {string} modId A mod UUID or slug
         * @param {string} versionId A version UUID or slug
         * @param {Version} version The version data to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVersion(modId: string, versionId: string, version: Version, options?: any): AxiosPromise<Version> {
            return localVarFp.updateVersion(modId, versionId, version, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for appendModToTeam operation in ModApi.
 * @export
 * @interface ModApiAppendModToTeamRequest
 */
export interface ModApiAppendModToTeamRequest {
    /**
     * A mod UUID or slug
     * @type {string}
     * @memberof ModApiAppendModToTeam
     */
    readonly modId: string

    /**
     * The mod team data to assign
     * @type {ModTeamParams}
     * @memberof ModApiAppendModToTeam
     */
    readonly modTeam: ModTeamParams
}

/**
 * Request parameters for appendModToUser operation in ModApi.
 * @export
 * @interface ModApiAppendModToUserRequest
 */
export interface ModApiAppendModToUserRequest {
    /**
     * A mod UUID or slug
     * @type {string}
     * @memberof ModApiAppendModToUser
     */
    readonly modId: string

    /**
     * The mod user data to assign
     * @type {ModUserParams}
     * @memberof ModApiAppendModToUser
     */
    readonly modUser: ModUserParams
}

/**
 * Request parameters for appendVersionToBuild operation in ModApi.
 * @export
 * @interface ModApiAppendVersionToBuildRequest
 */
export interface ModApiAppendVersionToBuildRequest {
    /**
     * A mod UUID or slug
     * @type {string}
     * @memberof ModApiAppendVersionToBuild
     */
    readonly modId: string

    /**
     * A version UUID or slug
     * @type {string}
     * @memberof ModApiAppendVersionToBuild
     */
    readonly versionId: string

    /**
     * The build data to append to version
     * @type {VersionBuildParams}
     * @memberof ModApiAppendVersionToBuild
     */
    readonly versionBuild: VersionBuildParams
}

/**
 * Request parameters for createMod operation in ModApi.
 * @export
 * @interface ModApiCreateModRequest
 */
export interface ModApiCreateModRequest {
    /**
     * The mod data to create
     * @type {Mod}
     * @memberof ModApiCreateMod
     */
    readonly mod: Mod
}

/**
 * Request parameters for createVersion operation in ModApi.
 * @export
 * @interface ModApiCreateVersionRequest
 */
export interface ModApiCreateVersionRequest {
    /**
     * A mod UUID or slug
     * @type {string}
     * @memberof ModApiCreateVersion
     */
    readonly modId: string

    /**
     * The version data to create
     * @type {Version}
     * @memberof ModApiCreateVersion
     */
    readonly version: Version
}

/**
 * Request parameters for deleteMod operation in ModApi.
 * @export
 * @interface ModApiDeleteModRequest
 */
export interface ModApiDeleteModRequest {
    /**
     * A mod UUID or slug
     * @type {string}
     * @memberof ModApiDeleteMod
     */
    readonly modId: string
}

/**
 * Request parameters for deleteModFromTeam operation in ModApi.
 * @export
 * @interface ModApiDeleteModFromTeamRequest
 */
export interface ModApiDeleteModFromTeamRequest {
    /**
     * A mod UUID or slug
     * @type {string}
     * @memberof ModApiDeleteModFromTeam
     */
    readonly modId: string

    /**
     * The mod team data to delete
     * @type {ModTeamParams}
     * @memberof ModApiDeleteModFromTeam
     */
    readonly modTeam: ModTeamParams
}

/**
 * Request parameters for deleteModFromUser operation in ModApi.
 * @export
 * @interface ModApiDeleteModFromUserRequest
 */
export interface ModApiDeleteModFromUserRequest {
    /**
     * A mod UUID or slug
     * @type {string}
     * @memberof ModApiDeleteModFromUser
     */
    readonly modId: string

    /**
     * The mod user data to delete
     * @type {ModUserParams}
     * @memberof ModApiDeleteModFromUser
     */
    readonly modUser: ModUserParams
}

/**
 * Request parameters for deleteVersion operation in ModApi.
 * @export
 * @interface ModApiDeleteVersionRequest
 */
export interface ModApiDeleteVersionRequest {
    /**
     * A mod UUID or slug
     * @type {string}
     * @memberof ModApiDeleteVersion
     */
    readonly modId: string

    /**
     * A version UUID or slug
     * @type {string}
     * @memberof ModApiDeleteVersion
     */
    readonly versionId: string
}

/**
 * Request parameters for deleteVersionFromBuild operation in ModApi.
 * @export
 * @interface ModApiDeleteVersionFromBuildRequest
 */
export interface ModApiDeleteVersionFromBuildRequest {
    /**
     * A mod UUID or slug
     * @type {string}
     * @memberof ModApiDeleteVersionFromBuild
     */
    readonly modId: string

    /**
     * A version UUID or slug
     * @type {string}
     * @memberof ModApiDeleteVersionFromBuild
     */
    readonly versionId: string

    /**
     * The build data to unlink from version
     * @type {VersionBuildParams}
     * @memberof ModApiDeleteVersionFromBuild
     */
    readonly versionBuild: VersionBuildParams
}

/**
 * Request parameters for listModTeams operation in ModApi.
 * @export
 * @interface ModApiListModTeamsRequest
 */
export interface ModApiListModTeamsRequest {
    /**
     * A mod UUID or slug
     * @type {string}
     * @memberof ModApiListModTeams
     */
    readonly modId: string
}

/**
 * Request parameters for listModUsers operation in ModApi.
 * @export
 * @interface ModApiListModUsersRequest
 */
export interface ModApiListModUsersRequest {
    /**
     * A mod UUID or slug
     * @type {string}
     * @memberof ModApiListModUsers
     */
    readonly modId: string
}

/**
 * Request parameters for listVersionBuilds operation in ModApi.
 * @export
 * @interface ModApiListVersionBuildsRequest
 */
export interface ModApiListVersionBuildsRequest {
    /**
     * A mod UUID or slug
     * @type {string}
     * @memberof ModApiListVersionBuilds
     */
    readonly modId: string

    /**
     * A version UUID or slug
     * @type {string}
     * @memberof ModApiListVersionBuilds
     */
    readonly versionId: string
}

/**
 * Request parameters for listVersions operation in ModApi.
 * @export
 * @interface ModApiListVersionsRequest
 */
export interface ModApiListVersionsRequest {
    /**
     * A mod UUID or slug
     * @type {string}
     * @memberof ModApiListVersions
     */
    readonly modId: string
}

/**
 * Request parameters for permitModTeam operation in ModApi.
 * @export
 * @interface ModApiPermitModTeamRequest
 */
export interface ModApiPermitModTeamRequest {
    /**
     * A mod UUID or slug
     * @type {string}
     * @memberof ModApiPermitModTeam
     */
    readonly modId: string

    /**
     * The mod team data to update
     * @type {ModTeamParams}
     * @memberof ModApiPermitModTeam
     */
    readonly modTeam: ModTeamParams
}

/**
 * Request parameters for permitModUser operation in ModApi.
 * @export
 * @interface ModApiPermitModUserRequest
 */
export interface ModApiPermitModUserRequest {
    /**
     * A mod UUID or slug
     * @type {string}
     * @memberof ModApiPermitModUser
     */
    readonly modId: string

    /**
     * The mod user data to update
     * @type {ModUserParams}
     * @memberof ModApiPermitModUser
     */
    readonly modUser: ModUserParams
}

/**
 * Request parameters for showMod operation in ModApi.
 * @export
 * @interface ModApiShowModRequest
 */
export interface ModApiShowModRequest {
    /**
     * A mod UUID or slug
     * @type {string}
     * @memberof ModApiShowMod
     */
    readonly modId: string
}

/**
 * Request parameters for showVersion operation in ModApi.
 * @export
 * @interface ModApiShowVersionRequest
 */
export interface ModApiShowVersionRequest {
    /**
     * A mod UUID or slug
     * @type {string}
     * @memberof ModApiShowVersion
     */
    readonly modId: string

    /**
     * A version UUID or slug
     * @type {string}
     * @memberof ModApiShowVersion
     */
    readonly versionId: string
}

/**
 * Request parameters for updateMod operation in ModApi.
 * @export
 * @interface ModApiUpdateModRequest
 */
export interface ModApiUpdateModRequest {
    /**
     * A mod UUID or slug
     * @type {string}
     * @memberof ModApiUpdateMod
     */
    readonly modId: string

    /**
     * The mod data to update
     * @type {Mod}
     * @memberof ModApiUpdateMod
     */
    readonly mod: Mod
}

/**
 * Request parameters for updateVersion operation in ModApi.
 * @export
 * @interface ModApiUpdateVersionRequest
 */
export interface ModApiUpdateVersionRequest {
    /**
     * A mod UUID or slug
     * @type {string}
     * @memberof ModApiUpdateVersion
     */
    readonly modId: string

    /**
     * A version UUID or slug
     * @type {string}
     * @memberof ModApiUpdateVersion
     */
    readonly versionId: string

    /**
     * The version data to update
     * @type {Version}
     * @memberof ModApiUpdateVersion
     */
    readonly version: Version
}

/**
 * ModApi - object-oriented interface
 * @export
 * @class ModApi
 * @extends {BaseAPI}
 */
export class ModApi extends BaseAPI {
    /**
     * 
     * @summary Assign a team to mod
     * @param {ModApiAppendModToTeamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModApi
     */
    public appendModToTeam(requestParameters: ModApiAppendModToTeamRequest, options?: AxiosRequestConfig) {
        return ModApiFp(this.configuration).appendModToTeam(requestParameters.modId, requestParameters.modTeam, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Assign a user to mod
     * @param {ModApiAppendModToUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModApi
     */
    public appendModToUser(requestParameters: ModApiAppendModToUserRequest, options?: AxiosRequestConfig) {
        return ModApiFp(this.configuration).appendModToUser(requestParameters.modId, requestParameters.modUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Assign a build to a version
     * @param {ModApiAppendVersionToBuildRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModApi
     */
    public appendVersionToBuild(requestParameters: ModApiAppendVersionToBuildRequest, options?: AxiosRequestConfig) {
        return ModApiFp(this.configuration).appendVersionToBuild(requestParameters.modId, requestParameters.versionId, requestParameters.versionBuild, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new mod
     * @param {ModApiCreateModRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModApi
     */
    public createMod(requestParameters: ModApiCreateModRequest, options?: AxiosRequestConfig) {
        return ModApiFp(this.configuration).createMod(requestParameters.mod, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new version for a mod
     * @param {ModApiCreateVersionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModApi
     */
    public createVersion(requestParameters: ModApiCreateVersionRequest, options?: AxiosRequestConfig) {
        return ModApiFp(this.configuration).createVersion(requestParameters.modId, requestParameters.version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a specific mod
     * @param {ModApiDeleteModRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModApi
     */
    public deleteMod(requestParameters: ModApiDeleteModRequest, options?: AxiosRequestConfig) {
        return ModApiFp(this.configuration).deleteMod(requestParameters.modId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a team from mod
     * @param {ModApiDeleteModFromTeamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModApi
     */
    public deleteModFromTeam(requestParameters: ModApiDeleteModFromTeamRequest, options?: AxiosRequestConfig) {
        return ModApiFp(this.configuration).deleteModFromTeam(requestParameters.modId, requestParameters.modTeam, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a user from mod
     * @param {ModApiDeleteModFromUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModApi
     */
    public deleteModFromUser(requestParameters: ModApiDeleteModFromUserRequest, options?: AxiosRequestConfig) {
        return ModApiFp(this.configuration).deleteModFromUser(requestParameters.modId, requestParameters.modUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a specific version for a mod
     * @param {ModApiDeleteVersionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModApi
     */
    public deleteVersion(requestParameters: ModApiDeleteVersionRequest, options?: AxiosRequestConfig) {
        return ModApiFp(this.configuration).deleteVersion(requestParameters.modId, requestParameters.versionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unlink a build from a version
     * @param {ModApiDeleteVersionFromBuildRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModApi
     */
    public deleteVersionFromBuild(requestParameters: ModApiDeleteVersionFromBuildRequest, options?: AxiosRequestConfig) {
        return ModApiFp(this.configuration).deleteVersionFromBuild(requestParameters.modId, requestParameters.versionId, requestParameters.versionBuild, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch all teams assigned to mod
     * @param {ModApiListModTeamsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModApi
     */
    public listModTeams(requestParameters: ModApiListModTeamsRequest, options?: AxiosRequestConfig) {
        return ModApiFp(this.configuration).listModTeams(requestParameters.modId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch all users assigned to mod
     * @param {ModApiListModUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModApi
     */
    public listModUsers(requestParameters: ModApiListModUsersRequest, options?: AxiosRequestConfig) {
        return ModApiFp(this.configuration).listModUsers(requestParameters.modId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch all available mods
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModApi
     */
    public listMods(options?: AxiosRequestConfig) {
        return ModApiFp(this.configuration).listMods(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch all builds assigned to version
     * @param {ModApiListVersionBuildsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModApi
     */
    public listVersionBuilds(requestParameters: ModApiListVersionBuildsRequest, options?: AxiosRequestConfig) {
        return ModApiFp(this.configuration).listVersionBuilds(requestParameters.modId, requestParameters.versionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch all available versions for a mod
     * @param {ModApiListVersionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModApi
     */
    public listVersions(requestParameters: ModApiListVersionsRequest, options?: AxiosRequestConfig) {
        return ModApiFp(this.configuration).listVersions(requestParameters.modId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update team perms for mod
     * @param {ModApiPermitModTeamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModApi
     */
    public permitModTeam(requestParameters: ModApiPermitModTeamRequest, options?: AxiosRequestConfig) {
        return ModApiFp(this.configuration).permitModTeam(requestParameters.modId, requestParameters.modTeam, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user perms for mod
     * @param {ModApiPermitModUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModApi
     */
    public permitModUser(requestParameters: ModApiPermitModUserRequest, options?: AxiosRequestConfig) {
        return ModApiFp(this.configuration).permitModUser(requestParameters.modId, requestParameters.modUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch a specific mod
     * @param {ModApiShowModRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModApi
     */
    public showMod(requestParameters: ModApiShowModRequest, options?: AxiosRequestConfig) {
        return ModApiFp(this.configuration).showMod(requestParameters.modId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch a specific version for a mod
     * @param {ModApiShowVersionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModApi
     */
    public showVersion(requestParameters: ModApiShowVersionRequest, options?: AxiosRequestConfig) {
        return ModApiFp(this.configuration).showVersion(requestParameters.modId, requestParameters.versionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a specific mod
     * @param {ModApiUpdateModRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModApi
     */
    public updateMod(requestParameters: ModApiUpdateModRequest, options?: AxiosRequestConfig) {
        return ModApiFp(this.configuration).updateMod(requestParameters.modId, requestParameters.mod, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a specific version for a mod
     * @param {ModApiUpdateVersionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModApi
     */
    public updateVersion(requestParameters: ModApiUpdateVersionRequest, options?: AxiosRequestConfig) {
        return ModApiFp(this.configuration).updateVersion(requestParameters.modId, requestParameters.versionId, requestParameters.version, options).then((request) => request(this.axios, this.basePath));
    }
}
