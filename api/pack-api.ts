/* tslint:disable */
/* eslint-disable */
/**
 * Kleister OpenAPI
 * API definition for Kleister, manage mod packs for Minecraft
 *
 * The version of the OpenAPI document: 1.0.0-alpha1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { Build } from '../model';
// @ts-ignore
import { BuildVersion } from '../model';
// @ts-ignore
import { BuildVersionParams } from '../model';
// @ts-ignore
import { GeneralError } from '../model';
// @ts-ignore
import { Pack } from '../model';
// @ts-ignore
import { PackTeamParams } from '../model';
// @ts-ignore
import { PackUserParams } from '../model';
// @ts-ignore
import { TeamPack } from '../model';
// @ts-ignore
import { UserPack } from '../model';
// @ts-ignore
import { ValidationError } from '../model';
/**
 * PackApi - axios parameter creator
 * @export
 */
export const PackApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Assign a version to a build
         * @param {string} packId A pack UUID or slug
         * @param {string} buildId A build UUID or slug
         * @param {BuildVersionParams} buildVersion The version data to append to build
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appendBuildToVersion: async (packId: string, buildId: string, buildVersion: BuildVersionParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packId' is not null or undefined
            assertParamExists('appendBuildToVersion', 'packId', packId)
            // verify required parameter 'buildId' is not null or undefined
            assertParamExists('appendBuildToVersion', 'buildId', buildId)
            // verify required parameter 'buildVersion' is not null or undefined
            assertParamExists('appendBuildToVersion', 'buildVersion', buildVersion)
            const localVarPath = `/packs/{pack_id}/builds/{build_id}/versions`
                .replace(`{${"pack_id"}}`, encodeURIComponent(String(packId)))
                .replace(`{${"build_id"}}`, encodeURIComponent(String(buildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(buildVersion, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Assign a team to pack
         * @param {string} packId A pack UUID or slug
         * @param {PackTeamParams} packTeam The pack team data to assign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appendPackToTeam: async (packId: string, packTeam: PackTeamParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packId' is not null or undefined
            assertParamExists('appendPackToTeam', 'packId', packId)
            // verify required parameter 'packTeam' is not null or undefined
            assertParamExists('appendPackToTeam', 'packTeam', packTeam)
            const localVarPath = `/packs/{pack_id}/teams`
                .replace(`{${"pack_id"}}`, encodeURIComponent(String(packId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(packTeam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Assign a user to pack
         * @param {string} packId A pack UUID or slug
         * @param {PackUserParams} packUser The pack user data to assign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appendPackToUser: async (packId: string, packUser: PackUserParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packId' is not null or undefined
            assertParamExists('appendPackToUser', 'packId', packId)
            // verify required parameter 'packUser' is not null or undefined
            assertParamExists('appendPackToUser', 'packUser', packUser)
            const localVarPath = `/packs/{pack_id}/users`
                .replace(`{${"pack_id"}}`, encodeURIComponent(String(packId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(packUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new build for a pack
         * @param {string} packId A pack UUID or slug
         * @param {Build} build The build data to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBuild: async (packId: string, build: Build, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packId' is not null or undefined
            assertParamExists('createBuild', 'packId', packId)
            // verify required parameter 'build' is not null or undefined
            assertParamExists('createBuild', 'build', build)
            const localVarPath = `/packs/{pack_id}/builds`
                .replace(`{${"pack_id"}}`, encodeURIComponent(String(packId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(build, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new pack
         * @param {Pack} pack The pack data to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPack: async (pack: Pack, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pack' is not null or undefined
            assertParamExists('createPack', 'pack', pack)
            const localVarPath = `/packs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pack, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a specific build for a pack
         * @param {string} packId A pack UUID or slug
         * @param {string} buildId A build UUID or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBuild: async (packId: string, buildId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packId' is not null or undefined
            assertParamExists('deleteBuild', 'packId', packId)
            // verify required parameter 'buildId' is not null or undefined
            assertParamExists('deleteBuild', 'buildId', buildId)
            const localVarPath = `/packs/{pack_id}/builds/{build_id}`
                .replace(`{${"pack_id"}}`, encodeURIComponent(String(packId)))
                .replace(`{${"build_id"}}`, encodeURIComponent(String(buildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unlink a version from a build
         * @param {string} packId A pack UUID or slug
         * @param {string} buildId A build UUID or slug
         * @param {BuildVersionParams} buildVersion The version data to unlink from build
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBuildFromVersion: async (packId: string, buildId: string, buildVersion: BuildVersionParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packId' is not null or undefined
            assertParamExists('deleteBuildFromVersion', 'packId', packId)
            // verify required parameter 'buildId' is not null or undefined
            assertParamExists('deleteBuildFromVersion', 'buildId', buildId)
            // verify required parameter 'buildVersion' is not null or undefined
            assertParamExists('deleteBuildFromVersion', 'buildVersion', buildVersion)
            const localVarPath = `/packs/{pack_id}/builds/{build_id}/versions`
                .replace(`{${"pack_id"}}`, encodeURIComponent(String(packId)))
                .replace(`{${"build_id"}}`, encodeURIComponent(String(buildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(buildVersion, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a specific pack
         * @param {string} packId A pack UUID or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePack: async (packId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packId' is not null or undefined
            assertParamExists('deletePack', 'packId', packId)
            const localVarPath = `/packs/{pack_id}`
                .replace(`{${"pack_id"}}`, encodeURIComponent(String(packId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a team from pack
         * @param {string} packId A pack UUID or slug
         * @param {PackTeamParams} packTeam The pack team data to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePackFromTeam: async (packId: string, packTeam: PackTeamParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packId' is not null or undefined
            assertParamExists('deletePackFromTeam', 'packId', packId)
            // verify required parameter 'packTeam' is not null or undefined
            assertParamExists('deletePackFromTeam', 'packTeam', packTeam)
            const localVarPath = `/packs/{pack_id}/teams`
                .replace(`{${"pack_id"}}`, encodeURIComponent(String(packId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(packTeam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a user from pack
         * @param {string} packId A pack UUID or slug
         * @param {PackUserParams} packUser The pack user data to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePackFromUser: async (packId: string, packUser: PackUserParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packId' is not null or undefined
            assertParamExists('deletePackFromUser', 'packId', packId)
            // verify required parameter 'packUser' is not null or undefined
            assertParamExists('deletePackFromUser', 'packUser', packUser)
            const localVarPath = `/packs/{pack_id}/users`
                .replace(`{${"pack_id"}}`, encodeURIComponent(String(packId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(packUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch all versions assigned to build
         * @param {string} packId A pack UUID or slug
         * @param {string} buildId A build UUID or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBuildVersions: async (packId: string, buildId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packId' is not null or undefined
            assertParamExists('listBuildVersions', 'packId', packId)
            // verify required parameter 'buildId' is not null or undefined
            assertParamExists('listBuildVersions', 'buildId', buildId)
            const localVarPath = `/packs/{pack_id}/builds/{build_id}/versions`
                .replace(`{${"pack_id"}}`, encodeURIComponent(String(packId)))
                .replace(`{${"build_id"}}`, encodeURIComponent(String(buildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch all available builds for a pack
         * @param {string} packId A pack UUID or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBuilds: async (packId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packId' is not null or undefined
            assertParamExists('listBuilds', 'packId', packId)
            const localVarPath = `/packs/{pack_id}/builds`
                .replace(`{${"pack_id"}}`, encodeURIComponent(String(packId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch all teams assigned to pack
         * @param {string} packId A pack UUID or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPackTeams: async (packId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packId' is not null or undefined
            assertParamExists('listPackTeams', 'packId', packId)
            const localVarPath = `/packs/{pack_id}/teams`
                .replace(`{${"pack_id"}}`, encodeURIComponent(String(packId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch all users assigned to pack
         * @param {string} packId A pack UUID or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPackUsers: async (packId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packId' is not null or undefined
            assertParamExists('listPackUsers', 'packId', packId)
            const localVarPath = `/packs/{pack_id}/users`
                .replace(`{${"pack_id"}}`, encodeURIComponent(String(packId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch all available packs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPacks: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/packs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update team perms for pack
         * @param {string} packId A pack UUID or slug
         * @param {PackTeamParams} packTeam The pack team data to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permitPackTeam: async (packId: string, packTeam: PackTeamParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packId' is not null or undefined
            assertParamExists('permitPackTeam', 'packId', packId)
            // verify required parameter 'packTeam' is not null or undefined
            assertParamExists('permitPackTeam', 'packTeam', packTeam)
            const localVarPath = `/packs/{pack_id}/teams`
                .replace(`{${"pack_id"}}`, encodeURIComponent(String(packId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(packTeam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user perms for pack
         * @param {string} packId A pack UUID or slug
         * @param {PackUserParams} packUser The pack user data to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permitPackUser: async (packId: string, packUser: PackUserParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packId' is not null or undefined
            assertParamExists('permitPackUser', 'packId', packId)
            // verify required parameter 'packUser' is not null or undefined
            assertParamExists('permitPackUser', 'packUser', packUser)
            const localVarPath = `/packs/{pack_id}/users`
                .replace(`{${"pack_id"}}`, encodeURIComponent(String(packId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(packUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch a specific build for a pack
         * @param {string} packId A pack UUID or slug
         * @param {string} buildId A build UUID or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showBuild: async (packId: string, buildId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packId' is not null or undefined
            assertParamExists('showBuild', 'packId', packId)
            // verify required parameter 'buildId' is not null or undefined
            assertParamExists('showBuild', 'buildId', buildId)
            const localVarPath = `/packs/{pack_id}/builds/{build_id}`
                .replace(`{${"pack_id"}}`, encodeURIComponent(String(packId)))
                .replace(`{${"build_id"}}`, encodeURIComponent(String(buildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch a specific pack
         * @param {string} packId A pack UUID or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showPack: async (packId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packId' is not null or undefined
            assertParamExists('showPack', 'packId', packId)
            const localVarPath = `/packs/{pack_id}`
                .replace(`{${"pack_id"}}`, encodeURIComponent(String(packId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a specific build for a pack
         * @param {string} packId A pack UUID or slug
         * @param {string} buildId A build UUID or slug
         * @param {Build} build The build data to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBuild: async (packId: string, buildId: string, build: Build, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packId' is not null or undefined
            assertParamExists('updateBuild', 'packId', packId)
            // verify required parameter 'buildId' is not null or undefined
            assertParamExists('updateBuild', 'buildId', buildId)
            // verify required parameter 'build' is not null or undefined
            assertParamExists('updateBuild', 'build', build)
            const localVarPath = `/packs/{pack_id}/builds/{build_id}`
                .replace(`{${"pack_id"}}`, encodeURIComponent(String(packId)))
                .replace(`{${"build_id"}}`, encodeURIComponent(String(buildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(build, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a specific pack
         * @param {string} packId A pack UUID or slug
         * @param {Pack} pack The pack data to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePack: async (packId: string, pack: Pack, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packId' is not null or undefined
            assertParamExists('updatePack', 'packId', packId)
            // verify required parameter 'pack' is not null or undefined
            assertParamExists('updatePack', 'pack', pack)
            const localVarPath = `/packs/{pack_id}`
                .replace(`{${"pack_id"}}`, encodeURIComponent(String(packId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pack, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PackApi - functional programming interface
 * @export
 */
export const PackApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PackApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Assign a version to a build
         * @param {string} packId A pack UUID or slug
         * @param {string} buildId A build UUID or slug
         * @param {BuildVersionParams} buildVersion The version data to append to build
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appendBuildToVersion(packId: string, buildId: string, buildVersion: BuildVersionParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeneralError>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appendBuildToVersion(packId, buildId, buildVersion, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Assign a team to pack
         * @param {string} packId A pack UUID or slug
         * @param {PackTeamParams} packTeam The pack team data to assign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appendPackToTeam(packId: string, packTeam: PackTeamParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeneralError>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appendPackToTeam(packId, packTeam, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Assign a user to pack
         * @param {string} packId A pack UUID or slug
         * @param {PackUserParams} packUser The pack user data to assign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appendPackToUser(packId: string, packUser: PackUserParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeneralError>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appendPackToUser(packId, packUser, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new build for a pack
         * @param {string} packId A pack UUID or slug
         * @param {Build} build The build data to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBuild(packId: string, build: Build, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Build>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBuild(packId, build, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new pack
         * @param {Pack} pack The pack data to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPack(pack: Pack, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pack>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPack(pack, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a specific build for a pack
         * @param {string} packId A pack UUID or slug
         * @param {string} buildId A build UUID or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBuild(packId: string, buildId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeneralError>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBuild(packId, buildId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unlink a version from a build
         * @param {string} packId A pack UUID or slug
         * @param {string} buildId A build UUID or slug
         * @param {BuildVersionParams} buildVersion The version data to unlink from build
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBuildFromVersion(packId: string, buildId: string, buildVersion: BuildVersionParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeneralError>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBuildFromVersion(packId, buildId, buildVersion, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a specific pack
         * @param {string} packId A pack UUID or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePack(packId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeneralError>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePack(packId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove a team from pack
         * @param {string} packId A pack UUID or slug
         * @param {PackTeamParams} packTeam The pack team data to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePackFromTeam(packId: string, packTeam: PackTeamParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeneralError>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePackFromTeam(packId, packTeam, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove a user from pack
         * @param {string} packId A pack UUID or slug
         * @param {PackUserParams} packUser The pack user data to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePackFromUser(packId: string, packUser: PackUserParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeneralError>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePackFromUser(packId, packUser, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetch all versions assigned to build
         * @param {string} packId A pack UUID or slug
         * @param {string} buildId A build UUID or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBuildVersions(packId: string, buildId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BuildVersion>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBuildVersions(packId, buildId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetch all available builds for a pack
         * @param {string} packId A pack UUID or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBuilds(packId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Build>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBuilds(packId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetch all teams assigned to pack
         * @param {string} packId A pack UUID or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPackTeams(packId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TeamPack>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPackTeams(packId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetch all users assigned to pack
         * @param {string} packId A pack UUID or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPackUsers(packId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserPack>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPackUsers(packId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetch all available packs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPacks(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Pack>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPacks(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update team perms for pack
         * @param {string} packId A pack UUID or slug
         * @param {PackTeamParams} packTeam The pack team data to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async permitPackTeam(packId: string, packTeam: PackTeamParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeneralError>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.permitPackTeam(packId, packTeam, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update user perms for pack
         * @param {string} packId A pack UUID or slug
         * @param {PackUserParams} packUser The pack user data to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async permitPackUser(packId: string, packUser: PackUserParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeneralError>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.permitPackUser(packId, packUser, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetch a specific build for a pack
         * @param {string} packId A pack UUID or slug
         * @param {string} buildId A build UUID or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showBuild(packId: string, buildId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Build>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showBuild(packId, buildId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetch a specific pack
         * @param {string} packId A pack UUID or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showPack(packId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pack>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showPack(packId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a specific build for a pack
         * @param {string} packId A pack UUID or slug
         * @param {string} buildId A build UUID or slug
         * @param {Build} build The build data to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBuild(packId: string, buildId: string, build: Build, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Build>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBuild(packId, buildId, build, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a specific pack
         * @param {string} packId A pack UUID or slug
         * @param {Pack} pack The pack data to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePack(packId: string, pack: Pack, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pack>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePack(packId, pack, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PackApi - factory interface
 * @export
 */
export const PackApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PackApiFp(configuration)
    return {
        /**
         * 
         * @summary Assign a version to a build
         * @param {string} packId A pack UUID or slug
         * @param {string} buildId A build UUID or slug
         * @param {BuildVersionParams} buildVersion The version data to append to build
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appendBuildToVersion(packId: string, buildId: string, buildVersion: BuildVersionParams, options?: any): AxiosPromise<GeneralError> {
            return localVarFp.appendBuildToVersion(packId, buildId, buildVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Assign a team to pack
         * @param {string} packId A pack UUID or slug
         * @param {PackTeamParams} packTeam The pack team data to assign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appendPackToTeam(packId: string, packTeam: PackTeamParams, options?: any): AxiosPromise<GeneralError> {
            return localVarFp.appendPackToTeam(packId, packTeam, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Assign a user to pack
         * @param {string} packId A pack UUID or slug
         * @param {PackUserParams} packUser The pack user data to assign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appendPackToUser(packId: string, packUser: PackUserParams, options?: any): AxiosPromise<GeneralError> {
            return localVarFp.appendPackToUser(packId, packUser, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new build for a pack
         * @param {string} packId A pack UUID or slug
         * @param {Build} build The build data to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBuild(packId: string, build: Build, options?: any): AxiosPromise<Build> {
            return localVarFp.createBuild(packId, build, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new pack
         * @param {Pack} pack The pack data to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPack(pack: Pack, options?: any): AxiosPromise<Pack> {
            return localVarFp.createPack(pack, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a specific build for a pack
         * @param {string} packId A pack UUID or slug
         * @param {string} buildId A build UUID or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBuild(packId: string, buildId: string, options?: any): AxiosPromise<GeneralError> {
            return localVarFp.deleteBuild(packId, buildId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unlink a version from a build
         * @param {string} packId A pack UUID or slug
         * @param {string} buildId A build UUID or slug
         * @param {BuildVersionParams} buildVersion The version data to unlink from build
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBuildFromVersion(packId: string, buildId: string, buildVersion: BuildVersionParams, options?: any): AxiosPromise<GeneralError> {
            return localVarFp.deleteBuildFromVersion(packId, buildId, buildVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a specific pack
         * @param {string} packId A pack UUID or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePack(packId: string, options?: any): AxiosPromise<GeneralError> {
            return localVarFp.deletePack(packId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a team from pack
         * @param {string} packId A pack UUID or slug
         * @param {PackTeamParams} packTeam The pack team data to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePackFromTeam(packId: string, packTeam: PackTeamParams, options?: any): AxiosPromise<GeneralError> {
            return localVarFp.deletePackFromTeam(packId, packTeam, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a user from pack
         * @param {string} packId A pack UUID or slug
         * @param {PackUserParams} packUser The pack user data to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePackFromUser(packId: string, packUser: PackUserParams, options?: any): AxiosPromise<GeneralError> {
            return localVarFp.deletePackFromUser(packId, packUser, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch all versions assigned to build
         * @param {string} packId A pack UUID or slug
         * @param {string} buildId A build UUID or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBuildVersions(packId: string, buildId: string, options?: any): AxiosPromise<Array<BuildVersion>> {
            return localVarFp.listBuildVersions(packId, buildId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch all available builds for a pack
         * @param {string} packId A pack UUID or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBuilds(packId: string, options?: any): AxiosPromise<Array<Build>> {
            return localVarFp.listBuilds(packId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch all teams assigned to pack
         * @param {string} packId A pack UUID or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPackTeams(packId: string, options?: any): AxiosPromise<Array<TeamPack>> {
            return localVarFp.listPackTeams(packId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch all users assigned to pack
         * @param {string} packId A pack UUID or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPackUsers(packId: string, options?: any): AxiosPromise<Array<UserPack>> {
            return localVarFp.listPackUsers(packId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch all available packs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPacks(options?: any): AxiosPromise<Array<Pack>> {
            return localVarFp.listPacks(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update team perms for pack
         * @param {string} packId A pack UUID or slug
         * @param {PackTeamParams} packTeam The pack team data to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permitPackTeam(packId: string, packTeam: PackTeamParams, options?: any): AxiosPromise<GeneralError> {
            return localVarFp.permitPackTeam(packId, packTeam, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user perms for pack
         * @param {string} packId A pack UUID or slug
         * @param {PackUserParams} packUser The pack user data to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permitPackUser(packId: string, packUser: PackUserParams, options?: any): AxiosPromise<GeneralError> {
            return localVarFp.permitPackUser(packId, packUser, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch a specific build for a pack
         * @param {string} packId A pack UUID or slug
         * @param {string} buildId A build UUID or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showBuild(packId: string, buildId: string, options?: any): AxiosPromise<Build> {
            return localVarFp.showBuild(packId, buildId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch a specific pack
         * @param {string} packId A pack UUID or slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showPack(packId: string, options?: any): AxiosPromise<Pack> {
            return localVarFp.showPack(packId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a specific build for a pack
         * @param {string} packId A pack UUID or slug
         * @param {string} buildId A build UUID or slug
         * @param {Build} build The build data to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBuild(packId: string, buildId: string, build: Build, options?: any): AxiosPromise<Build> {
            return localVarFp.updateBuild(packId, buildId, build, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a specific pack
         * @param {string} packId A pack UUID or slug
         * @param {Pack} pack The pack data to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePack(packId: string, pack: Pack, options?: any): AxiosPromise<Pack> {
            return localVarFp.updatePack(packId, pack, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for appendBuildToVersion operation in PackApi.
 * @export
 * @interface PackApiAppendBuildToVersionRequest
 */
export interface PackApiAppendBuildToVersionRequest {
    /**
     * A pack UUID or slug
     * @type {string}
     * @memberof PackApiAppendBuildToVersion
     */
    readonly packId: string

    /**
     * A build UUID or slug
     * @type {string}
     * @memberof PackApiAppendBuildToVersion
     */
    readonly buildId: string

    /**
     * The version data to append to build
     * @type {BuildVersionParams}
     * @memberof PackApiAppendBuildToVersion
     */
    readonly buildVersion: BuildVersionParams
}

/**
 * Request parameters for appendPackToTeam operation in PackApi.
 * @export
 * @interface PackApiAppendPackToTeamRequest
 */
export interface PackApiAppendPackToTeamRequest {
    /**
     * A pack UUID or slug
     * @type {string}
     * @memberof PackApiAppendPackToTeam
     */
    readonly packId: string

    /**
     * The pack team data to assign
     * @type {PackTeamParams}
     * @memberof PackApiAppendPackToTeam
     */
    readonly packTeam: PackTeamParams
}

/**
 * Request parameters for appendPackToUser operation in PackApi.
 * @export
 * @interface PackApiAppendPackToUserRequest
 */
export interface PackApiAppendPackToUserRequest {
    /**
     * A pack UUID or slug
     * @type {string}
     * @memberof PackApiAppendPackToUser
     */
    readonly packId: string

    /**
     * The pack user data to assign
     * @type {PackUserParams}
     * @memberof PackApiAppendPackToUser
     */
    readonly packUser: PackUserParams
}

/**
 * Request parameters for createBuild operation in PackApi.
 * @export
 * @interface PackApiCreateBuildRequest
 */
export interface PackApiCreateBuildRequest {
    /**
     * A pack UUID or slug
     * @type {string}
     * @memberof PackApiCreateBuild
     */
    readonly packId: string

    /**
     * The build data to create
     * @type {Build}
     * @memberof PackApiCreateBuild
     */
    readonly build: Build
}

/**
 * Request parameters for createPack operation in PackApi.
 * @export
 * @interface PackApiCreatePackRequest
 */
export interface PackApiCreatePackRequest {
    /**
     * The pack data to create
     * @type {Pack}
     * @memberof PackApiCreatePack
     */
    readonly pack: Pack
}

/**
 * Request parameters for deleteBuild operation in PackApi.
 * @export
 * @interface PackApiDeleteBuildRequest
 */
export interface PackApiDeleteBuildRequest {
    /**
     * A pack UUID or slug
     * @type {string}
     * @memberof PackApiDeleteBuild
     */
    readonly packId: string

    /**
     * A build UUID or slug
     * @type {string}
     * @memberof PackApiDeleteBuild
     */
    readonly buildId: string
}

/**
 * Request parameters for deleteBuildFromVersion operation in PackApi.
 * @export
 * @interface PackApiDeleteBuildFromVersionRequest
 */
export interface PackApiDeleteBuildFromVersionRequest {
    /**
     * A pack UUID or slug
     * @type {string}
     * @memberof PackApiDeleteBuildFromVersion
     */
    readonly packId: string

    /**
     * A build UUID or slug
     * @type {string}
     * @memberof PackApiDeleteBuildFromVersion
     */
    readonly buildId: string

    /**
     * The version data to unlink from build
     * @type {BuildVersionParams}
     * @memberof PackApiDeleteBuildFromVersion
     */
    readonly buildVersion: BuildVersionParams
}

/**
 * Request parameters for deletePack operation in PackApi.
 * @export
 * @interface PackApiDeletePackRequest
 */
export interface PackApiDeletePackRequest {
    /**
     * A pack UUID or slug
     * @type {string}
     * @memberof PackApiDeletePack
     */
    readonly packId: string
}

/**
 * Request parameters for deletePackFromTeam operation in PackApi.
 * @export
 * @interface PackApiDeletePackFromTeamRequest
 */
export interface PackApiDeletePackFromTeamRequest {
    /**
     * A pack UUID or slug
     * @type {string}
     * @memberof PackApiDeletePackFromTeam
     */
    readonly packId: string

    /**
     * The pack team data to delete
     * @type {PackTeamParams}
     * @memberof PackApiDeletePackFromTeam
     */
    readonly packTeam: PackTeamParams
}

/**
 * Request parameters for deletePackFromUser operation in PackApi.
 * @export
 * @interface PackApiDeletePackFromUserRequest
 */
export interface PackApiDeletePackFromUserRequest {
    /**
     * A pack UUID or slug
     * @type {string}
     * @memberof PackApiDeletePackFromUser
     */
    readonly packId: string

    /**
     * The pack user data to delete
     * @type {PackUserParams}
     * @memberof PackApiDeletePackFromUser
     */
    readonly packUser: PackUserParams
}

/**
 * Request parameters for listBuildVersions operation in PackApi.
 * @export
 * @interface PackApiListBuildVersionsRequest
 */
export interface PackApiListBuildVersionsRequest {
    /**
     * A pack UUID or slug
     * @type {string}
     * @memberof PackApiListBuildVersions
     */
    readonly packId: string

    /**
     * A build UUID or slug
     * @type {string}
     * @memberof PackApiListBuildVersions
     */
    readonly buildId: string
}

/**
 * Request parameters for listBuilds operation in PackApi.
 * @export
 * @interface PackApiListBuildsRequest
 */
export interface PackApiListBuildsRequest {
    /**
     * A pack UUID or slug
     * @type {string}
     * @memberof PackApiListBuilds
     */
    readonly packId: string
}

/**
 * Request parameters for listPackTeams operation in PackApi.
 * @export
 * @interface PackApiListPackTeamsRequest
 */
export interface PackApiListPackTeamsRequest {
    /**
     * A pack UUID or slug
     * @type {string}
     * @memberof PackApiListPackTeams
     */
    readonly packId: string
}

/**
 * Request parameters for listPackUsers operation in PackApi.
 * @export
 * @interface PackApiListPackUsersRequest
 */
export interface PackApiListPackUsersRequest {
    /**
     * A pack UUID or slug
     * @type {string}
     * @memberof PackApiListPackUsers
     */
    readonly packId: string
}

/**
 * Request parameters for permitPackTeam operation in PackApi.
 * @export
 * @interface PackApiPermitPackTeamRequest
 */
export interface PackApiPermitPackTeamRequest {
    /**
     * A pack UUID or slug
     * @type {string}
     * @memberof PackApiPermitPackTeam
     */
    readonly packId: string

    /**
     * The pack team data to update
     * @type {PackTeamParams}
     * @memberof PackApiPermitPackTeam
     */
    readonly packTeam: PackTeamParams
}

/**
 * Request parameters for permitPackUser operation in PackApi.
 * @export
 * @interface PackApiPermitPackUserRequest
 */
export interface PackApiPermitPackUserRequest {
    /**
     * A pack UUID or slug
     * @type {string}
     * @memberof PackApiPermitPackUser
     */
    readonly packId: string

    /**
     * The pack user data to update
     * @type {PackUserParams}
     * @memberof PackApiPermitPackUser
     */
    readonly packUser: PackUserParams
}

/**
 * Request parameters for showBuild operation in PackApi.
 * @export
 * @interface PackApiShowBuildRequest
 */
export interface PackApiShowBuildRequest {
    /**
     * A pack UUID or slug
     * @type {string}
     * @memberof PackApiShowBuild
     */
    readonly packId: string

    /**
     * A build UUID or slug
     * @type {string}
     * @memberof PackApiShowBuild
     */
    readonly buildId: string
}

/**
 * Request parameters for showPack operation in PackApi.
 * @export
 * @interface PackApiShowPackRequest
 */
export interface PackApiShowPackRequest {
    /**
     * A pack UUID or slug
     * @type {string}
     * @memberof PackApiShowPack
     */
    readonly packId: string
}

/**
 * Request parameters for updateBuild operation in PackApi.
 * @export
 * @interface PackApiUpdateBuildRequest
 */
export interface PackApiUpdateBuildRequest {
    /**
     * A pack UUID or slug
     * @type {string}
     * @memberof PackApiUpdateBuild
     */
    readonly packId: string

    /**
     * A build UUID or slug
     * @type {string}
     * @memberof PackApiUpdateBuild
     */
    readonly buildId: string

    /**
     * The build data to update
     * @type {Build}
     * @memberof PackApiUpdateBuild
     */
    readonly build: Build
}

/**
 * Request parameters for updatePack operation in PackApi.
 * @export
 * @interface PackApiUpdatePackRequest
 */
export interface PackApiUpdatePackRequest {
    /**
     * A pack UUID or slug
     * @type {string}
     * @memberof PackApiUpdatePack
     */
    readonly packId: string

    /**
     * The pack data to update
     * @type {Pack}
     * @memberof PackApiUpdatePack
     */
    readonly pack: Pack
}

/**
 * PackApi - object-oriented interface
 * @export
 * @class PackApi
 * @extends {BaseAPI}
 */
export class PackApi extends BaseAPI {
    /**
     * 
     * @summary Assign a version to a build
     * @param {PackApiAppendBuildToVersionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackApi
     */
    public appendBuildToVersion(requestParameters: PackApiAppendBuildToVersionRequest, options?: AxiosRequestConfig) {
        return PackApiFp(this.configuration).appendBuildToVersion(requestParameters.packId, requestParameters.buildId, requestParameters.buildVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Assign a team to pack
     * @param {PackApiAppendPackToTeamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackApi
     */
    public appendPackToTeam(requestParameters: PackApiAppendPackToTeamRequest, options?: AxiosRequestConfig) {
        return PackApiFp(this.configuration).appendPackToTeam(requestParameters.packId, requestParameters.packTeam, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Assign a user to pack
     * @param {PackApiAppendPackToUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackApi
     */
    public appendPackToUser(requestParameters: PackApiAppendPackToUserRequest, options?: AxiosRequestConfig) {
        return PackApiFp(this.configuration).appendPackToUser(requestParameters.packId, requestParameters.packUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new build for a pack
     * @param {PackApiCreateBuildRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackApi
     */
    public createBuild(requestParameters: PackApiCreateBuildRequest, options?: AxiosRequestConfig) {
        return PackApiFp(this.configuration).createBuild(requestParameters.packId, requestParameters.build, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new pack
     * @param {PackApiCreatePackRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackApi
     */
    public createPack(requestParameters: PackApiCreatePackRequest, options?: AxiosRequestConfig) {
        return PackApiFp(this.configuration).createPack(requestParameters.pack, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a specific build for a pack
     * @param {PackApiDeleteBuildRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackApi
     */
    public deleteBuild(requestParameters: PackApiDeleteBuildRequest, options?: AxiosRequestConfig) {
        return PackApiFp(this.configuration).deleteBuild(requestParameters.packId, requestParameters.buildId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unlink a version from a build
     * @param {PackApiDeleteBuildFromVersionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackApi
     */
    public deleteBuildFromVersion(requestParameters: PackApiDeleteBuildFromVersionRequest, options?: AxiosRequestConfig) {
        return PackApiFp(this.configuration).deleteBuildFromVersion(requestParameters.packId, requestParameters.buildId, requestParameters.buildVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a specific pack
     * @param {PackApiDeletePackRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackApi
     */
    public deletePack(requestParameters: PackApiDeletePackRequest, options?: AxiosRequestConfig) {
        return PackApiFp(this.configuration).deletePack(requestParameters.packId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a team from pack
     * @param {PackApiDeletePackFromTeamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackApi
     */
    public deletePackFromTeam(requestParameters: PackApiDeletePackFromTeamRequest, options?: AxiosRequestConfig) {
        return PackApiFp(this.configuration).deletePackFromTeam(requestParameters.packId, requestParameters.packTeam, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a user from pack
     * @param {PackApiDeletePackFromUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackApi
     */
    public deletePackFromUser(requestParameters: PackApiDeletePackFromUserRequest, options?: AxiosRequestConfig) {
        return PackApiFp(this.configuration).deletePackFromUser(requestParameters.packId, requestParameters.packUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch all versions assigned to build
     * @param {PackApiListBuildVersionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackApi
     */
    public listBuildVersions(requestParameters: PackApiListBuildVersionsRequest, options?: AxiosRequestConfig) {
        return PackApiFp(this.configuration).listBuildVersions(requestParameters.packId, requestParameters.buildId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch all available builds for a pack
     * @param {PackApiListBuildsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackApi
     */
    public listBuilds(requestParameters: PackApiListBuildsRequest, options?: AxiosRequestConfig) {
        return PackApiFp(this.configuration).listBuilds(requestParameters.packId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch all teams assigned to pack
     * @param {PackApiListPackTeamsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackApi
     */
    public listPackTeams(requestParameters: PackApiListPackTeamsRequest, options?: AxiosRequestConfig) {
        return PackApiFp(this.configuration).listPackTeams(requestParameters.packId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch all users assigned to pack
     * @param {PackApiListPackUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackApi
     */
    public listPackUsers(requestParameters: PackApiListPackUsersRequest, options?: AxiosRequestConfig) {
        return PackApiFp(this.configuration).listPackUsers(requestParameters.packId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch all available packs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackApi
     */
    public listPacks(options?: AxiosRequestConfig) {
        return PackApiFp(this.configuration).listPacks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update team perms for pack
     * @param {PackApiPermitPackTeamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackApi
     */
    public permitPackTeam(requestParameters: PackApiPermitPackTeamRequest, options?: AxiosRequestConfig) {
        return PackApiFp(this.configuration).permitPackTeam(requestParameters.packId, requestParameters.packTeam, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user perms for pack
     * @param {PackApiPermitPackUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackApi
     */
    public permitPackUser(requestParameters: PackApiPermitPackUserRequest, options?: AxiosRequestConfig) {
        return PackApiFp(this.configuration).permitPackUser(requestParameters.packId, requestParameters.packUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch a specific build for a pack
     * @param {PackApiShowBuildRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackApi
     */
    public showBuild(requestParameters: PackApiShowBuildRequest, options?: AxiosRequestConfig) {
        return PackApiFp(this.configuration).showBuild(requestParameters.packId, requestParameters.buildId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch a specific pack
     * @param {PackApiShowPackRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackApi
     */
    public showPack(requestParameters: PackApiShowPackRequest, options?: AxiosRequestConfig) {
        return PackApiFp(this.configuration).showPack(requestParameters.packId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a specific build for a pack
     * @param {PackApiUpdateBuildRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackApi
     */
    public updateBuild(requestParameters: PackApiUpdateBuildRequest, options?: AxiosRequestConfig) {
        return PackApiFp(this.configuration).updateBuild(requestParameters.packId, requestParameters.buildId, requestParameters.build, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a specific pack
     * @param {PackApiUpdatePackRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackApi
     */
    public updatePack(requestParameters: PackApiUpdatePackRequest, options?: AxiosRequestConfig) {
        return PackApiFp(this.configuration).updatePack(requestParameters.packId, requestParameters.pack, options).then((request) => request(this.axios, this.basePath));
    }
}
